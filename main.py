# -*- coding: utf-8 -*-
"""pinterest.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DRG7tDI2I6140Uh2L-SYFDcZTNUG7c4o
"""

import numpy as np
from PIL import Image
import pandas as pd
from tqdm import tqdm
from scipy.spatial import KDTree
import webcolors
import os
import random
#from pinterest import Api
import requests, json
import subprocess
import sys
from base64 import b64encode
import urllib.request
from selenium import webdriver
from urllib.request import urlopen
import re
#import pinterest
import requests 
from bs4 import BeautifulSoup 
from datetime import datetime
import math
from thecolorapi import color as thecolorapi_color
import matplotlib.pyplot as plt
from skimage import io
import time
import csv
from operator import indexOf



testurl = 'https://www.pinterest.com/miraculouswip/flowers/'

def convert_rgb_to_names(rgb_tuple):
    distance, index = kdt_db.query(rgb_tuple)
    return names[index], distance

'''
def convert_hsl_to_rgb(hsl_tuple):
  hsl_tuple[0] = round(hsl_tuple[0])
  hsl_tuple[1] = round(100*hsl_tuple[1])
  hsl_tuple[2] = round(100*hsl_tuple[2])
  color = thecolorapi_color(hsl = tuple(hsl_tuple))
  return color.rbg


def convert_hsl_to_rgb(hsl_tuple):
  h = round(hsl_tuple[0])
  s = round(100*hsl_tuple[1])
  l = round(100*hsl_tuple[2])
  result = requests.get(f"https://www.thecolorapi.com/id?hsl={h},{s}%,{l}%&format=json")
  rgb= result.json()["rgb"]
  return (rgb['r'], rgb['g'], rgb['b'])
'''
def convert_hsl_to_rgb(hsl_tuple):
  h = hsl_tuple[0]
  s = hsl_tuple[1]
  l = hsl_tuple[2]

  chroma = (1-abs(2*l - 1)) * s

  Hprime = h/60

  X = chroma*(1- abs((Hprime%2 ) -1))

  
  if Hprime <= 1:
    r1,g1,b1 = X,chroma,0
  elif Hprime <= 2:
    r1,g1,b1 = chroma,X,0
  elif Hprime <= 3:
    r1,g1,b1 = 0,chroma,X
  elif Hprime <= 4:
    r1,g1,b1 = 0,X,chroma
  elif Hprime <= 5:
    r1,g1,b1 = X,0,chroma
  elif Hprime <= 6:
    r1,g1,b1 = chroma,0,X
  
  m = l - 0.5* chroma

  r,g,b = round((m+r1)*255), round((m+g1)*255),round((m+b1)*255)
 # print(f"hsl: {hsl_tuple}")
 # print(f"rgb: {(r,g,b)}")
 # print(f"chroma, Hprime, X, m: {(chroma, Hprime, X, m)}")
  return (r,g,b)


def convert_rgb_to_json(rgb_tuple):
  r = round(rgb_tuple[0])
  g = round(rgb_tuple[1])
  b = round(rgb_tuple[2])
  result = requests.get(f"https://www.thecolorapi.com/id?rgb={r},{g}%,{b}%&format=json")
  return result.json()


def rgb_to_hex(rgb):
    rgb = tuple(rgb)
    return '#%02x%02x%02x' % rgb

checkFile = "colornamedict.csv"
 
 
 
if os.path.isfile(checkFile):
  pathExists = True
  colornamedict = {}#CHANGE ONCE I FIGURE OUT HOW TO FORMAT COLORDICT CSV
  with open('colornamedict.csv', 'r') as f: 
      read = csv.reader(f) 
      for row in read:
        if not row:
          continue
        if row[0] == "r":
          continue
        colornamedict[(int(row[0]), int(row[1]), int(row[2]))] = ((row[3]),float(row[4]))
else:
  pathExists = False
  colornamedict = {}
#print(pathExists)

#https://stackoverflow.com/questions/48225334/extracting-data-from-pinterest-using-beautifulsoup-python
#couldnt figure ^ out but could be useful

def getdata(url): 
    r = requests.get(url) 
    return r.text 
def checkURL(url):
  if 'www.pinterest.com/' in url:
    return True
  else:
    return False

def getImages(url):
  if checkURL(url):
    htmldata = getdata(url) 
    soup = BeautifulSoup(htmldata, 'html.parser')

    urlarr = []
    for item in soup.find_all('img'):
      urlarr.append(item['src'])
    return urlarr
  else:
    print("Invalid pinterest url")
def getImageFiles(url):
  skiplist = {'1e78a2658daa724a58773b2bdf98b68c.jpg', '37f894920d87d43da19cd5d9760e121c.jpg'}
  urlarr = getImages(url)
  foldername = f'pins_{datetime.now()}'
  os.mkdir(foldername)
  os.chdir(foldername)
  fnamearr = []
  for imageurl in urlarr:
    rev = imageurl[::-1]
    #print(rev[::-1])
    filename = rev[:rev.find('/')]
    filename = filename[::-1]

    if filename in skiplist:
      continue
    fnamearr.append(filename)

    urllib.request.urlretrieve(imageurl, filename)

    img = Image.open(filename)

    img.show()
  os.chdir('..')
  return fnamearr, foldername



def randrgf_img(img_og, numsamples=1000, disp = False, mode = "RGB"):
  img_og = img_og.convert(mode)
  imgarr = np.array(img_og)
  cellarr = []
  for _ in range(numsamples):
    i = random.randint(0, len(imgarr)-1)
    j = random.randint(0, len(imgarr[0])-1)
    cell = imgarr[i][j]
    if tuple(cell) in colornamedict.keys():
        tup = colornamedict[tuple(cell)]
    else:
      tup = convert_rgb_to_names(tuple(cell)) 
      colornamedict[tuple(cell)] = tup
    r = cell[0]
    g = cell[1]
    b = cell[2]
    cellarr.append([i,j,r,g,b, tup[0], tup[1],huecalc(r,g,b),satcalc(r,g,b),lightness(r,g,b),rgb_val(r,g,b)])

  #print(cellarr)
  imgpd = pd.DataFrame(columns=["row", "column", "R", "G", "B", "name", "distance", "hue", "saturation", "lightness", "val"], data = cellarr)
  imgpd['distance'] /= 255
  if disp:
    print(imgpd.name.value_counts().head(10))
  #print(f"imgpd.columns: {imgpd.columns}")
  return imgpd

def assemble_df_direct(url, numsamples = 1000,disp= False):
  #print("Assemble_direct")
  skiplist = {'1e78a2658daa724a58773b2bdf98b68c.jpg', '37f894920d87d43da19cd5d9760e121c.jpg'}
  urlarr = getImages(url)
  fnamearr = []
  df_arr = []
  for imageurl in urlarr:
    rev = imageurl[::-1]
    if disp:
      print(rev[::-1])
    filename = rev[:rev.find('/')]
    filename = filename[::-1]

    if filename in skiplist:
      continue
    fnamearr.append(filename)

    urllib.request.urlretrieve(imageurl, filename)

    img = Image.open(filename)

    df_arr.append(randrgf_img(img,numsamples=numsamples,disp = disp))#does HSL too
  

  returnpd = pd.concat(df_arr, sort = False)
  return returnpd

# a dictionary of all the hex and their respective names in css3

names = []
rgb_values = []

import json
 
# Opening JSON file
with open("colorapi.json") as file:
   data=file.read()
   colorapidict=json.loads(data)

for colormini in colorapidict["colors"]:
    name, hex = colormini["name"], "#"+colormini["hex"]
    names.append(name)
    rgb_values.append(webcolors.hex_to_rgb(hex))

kdt_db = KDTree(rgb_values)

colornamedict

def huecalc(r,g,b):
  r /= 255
  g /= 255
  b /= 255
  cmax = max(r,g,b)
  cmin = min(r,g,b)
  delta = cmax - cmin
  if delta == 0:
    return 0
  elif cmax == r:
    return 60*(((g-b)/delta)%6)
  elif cmax == g:
    return 60*(((b-r)/delta)+2)
  elif cmax == b:
    return 60*(((r-g)/delta)+4)
  else:
    return 0


def satcalc(r,g,b):
  lightcalc = lightness(r,g,b)
  r /= 255
  g /= 255
  b /= 255
  cmax = max(r,g,b)
  cmin = min(r,g,b)
  delta = cmax - cmin
  if delta == 0:
    return 0
  else:
    return (delta/(1-abs(2*lightcalc - 1)))

def lightness(r,g,b):
  r /= 255
  g /= 255
  b /= 255
  cmax = max(r,g,b)
  cmin = min(r,g,b)
  return ((cmax+cmin)/2)

def rgb_val(r,g,b):
  return (max(r,g,b)/255)



def randrgf(imgpath = "/content/test.jpg", numsamples=1000, disp = False):
  mode = "RGB"
  img_og = Image.open(imgpath).convert(mode)
  imgarr = np.array(img_og)
  cellarr = []
  for _ in range(numsamples):
    i = random.randint(0, len(imgarr)-1)
    j = random.randint(0, len(imgarr[0])-1)
    cell = imgarr[i][j]
    if tuple(cell) in colornamedict.keys():
        tup = colornamedict[tuple(cell)]
    else:
      tup = convert_rgb_to_names(tuple(cell)) 
      colornamedict[tuple(cell)] = tup
    
    cellarr.append([i,j,cell[0], cell[1], cell[2], tup[0], tup[1]])

  #print(cellarr)
  imgpd = pd.DataFrame(columns=["row", "column", "R", "G", "B", "name", "distance"], data = cellarr)

  if disp:
    print(imgpd.name.value_counts().head(10))
  #print(imgpd)
  return imgpd


def curvecheck(sat, light):
  if sat == 1:
    sat -= 0.01
  a = ((light/sat)-1)/(sat-1)
  b = 1-a

  xarr = np.asarray([0.1*i for i in range(10)])
  xarr += sat
  yarr = [a*x**2 + b*x for x in xarr]

  return xarr, yarr
  #double check this function, I ran into some issues with the curves going out of bounds at the boundary conditions

def hsl_distance(hsl_1, hsl_2):
  coord1 = (hsl_1[1]*np.cos(np.deg2rad(hsl_1[0])),hsl_1[1]*np.sin(np.deg2rad(hsl_1[0])), hsl_1[2])
  coord2 = (hsl_2[1]*np.cos(np.deg2rad(hsl_2[0])),hsl_2[1]*np.sin(np.deg2rad(hsl_2[0])), hsl_2[2])

  return math.sqrt((coord1[0]-coord2[0])**2+(coord1[1]-coord2[1])**2+(coord1[2]-coord2[2])**2)



def get_freqtable(colornames, color_df, color_quant = 0.2):
  freqtable = np.asarray([[name, len(color_df[color_df['name']==name]), round(color_df[color_df['name']==name]['hue'].mean(),3), round(color_df[color_df['name']==name]['saturation'].mean(),3), round(color_df[color_df['name']==name]['lightness'].mean(),3), round(color_df[color_df['name']==name]['distance'].mean(),4)] for name in colornames])
  freqtable = pd.DataFrame(columns = ["name", "freq","avg_hue","avg_saturation","avg_lightness", "avg_distance"], data= freqtable)
  freqtable["freq"]= pd.to_numeric(freqtable["freq"])
  freqtable.dropna()
  freqtable = freqtable[freqtable['freq'] != 0]
  freqtable["avg_hue"] = pd.to_numeric(freqtable["avg_hue"])
  freqtable["avg_saturation"]  = pd.to_numeric(freqtable["avg_saturation"])
  freqtable["avg_lightness"]= pd.to_numeric(freqtable["avg_lightness"])
  freqtable["avg_distance"]= pd.to_numeric(freqtable["avg_distance"])
  return freqtable

def swath_gen(h,xarr, yarr,rank, distrib):
  vals = [0,1,2,3,4,5,6,7,8,9]
  swatharr = tuple(zip(distrib, vals))
  xarr = list(xarr)
  yarr = list(yarr)
  if len(yarr) == 1:
    yarr = yarr[0]
  if len(xarr) == 1:
    xarr = xarr[0]
  keylist = sorted(swatharr, key = lambda x:x[0])
  top_n = rank*2
  keylist = [swatharr[i][1] for i in range(top_n)]
  #print(f"xarr: {xarr}")
  #print(f"yarr: {yarr}")
  additional= [[h,xarr[i],yarr[i]] for i in keylist]
  return additional

def get_colordf(testcombo_df, color_quant = .1):
  colornames = testcombo_df['name'].unique()
  #print(testcombo_df.columns)
  if testcombo_df["saturation"].mean() > 0.5:
    satbool = testcombo_df["saturation"] < testcombo_df["saturation"].quantile(1-color_quant)
  else:
    satbool = testcombo_df["saturation"] > testcombo_df["saturation"].quantile(color_quant)
  
  if testcombo_df["lightness"].mean() > 0.5:
    lightbool = testcombo_df["lightness"] < testcombo_df["lightness"].quantile(1-color_quant)
  else:
    lightbool = testcombo_df["lightness"] > testcombo_df["lightness"].quantile(color_quant)
  color_df = testcombo_df[lightbool & satbool]
  return colornames, color_df


def get_rankingdf(distance_df, color):
  ranking_df = distance_df.copy()
  ranking_df.drop("subtype", axis = 1, inplace = True)
  ranking_df = ranking_df[['prim_color','type', "score"]]
  ranking_df = ranking_df.groupby("type").aggregate(["sum"]).sort_values(('score','sum'), ascending = True)
  ranking_df.columns = [ "prim_color", "score"]
  ranking_df["prim_color"] = [color for _ in range(len(ranking_df))]
  ranking_df['score']/=ranking_df['score'].sum()
  self_score = ranking_df.iloc[0]["score"]
  #print(ranking_df.index)
  ranking_df=ranking_df.drop('Self')
  ranking_df['score']/=ranking_df['score'].sum()

  return ranking_df

def n_mostcommon(color_df, rgb_list, n):
  rgb_count = []
  for rgb in rgb_list:
    num_rgb = len(color_df[(abs(color_df["R"]-rgb[0]) < 5) & (abs(color_df["G"]-rgb[1]) < 5) & (abs(color_df["B"]-rgb[2]) < 0.05)])
    rgb_count.append([rgb, rgb_count])
  rgb_count = sorted(rgb_count, key = lambda x:x[1])
  return list(np.asarray(rgb_count)[:n,0])
def hue_distance_calc(h,xarr,yarr,df):
  lim = 400

  #print("hdc")
  #clock = ticktock()
  #clock.tick()
  hslarr = [[h, xarr[i],yarr[i]] for i in range(len(xarr))]
  distance = 0
  freqlist = [0,0,0,0,0,0,0,0,0,0]
  if len(df) < lim:
    for index,row in df.iterrows():
      temp_d = []
      
      row_hsl = [row["hue"],row["saturation"], row["lightness"]]
      for trip in hslarr:
        temp_d.append(hsl_distance(trip, row_hsl))
      distance += min(temp_d)
      freqlist[temp_d.index(min(temp_d))] += 1
    #clock.tock()
    #print("hdc end")
  else:
    for i in range(lim):
      index = random.randint(0, len(df)-1)
      row = df.iloc[index]
      
      temp_d = []
      
      row_hsl = [row["hue"],row["saturation"], row["lightness"]]
      for trip in hslarr:
        temp_d.append(hsl_distance(trip, row_hsl))
      distance += min(temp_d)
      freqlist[temp_d.index(min(temp_d))] += 1
    #clock.tock()
  return distance, np.asarray(freqlist)

def get_by_type(pal_type, subtype, color_df, color, freqtable, color_quant, pal_limit, palette_length, color_hue, xarr, yarr):
  #print(f"type: {pal_type}, subtype: {subtype}.")
  if pal_type == "Self":
    hue = color_hue
    huediff = 30
    huearr = [hue]
  elif pal_type == "Comp":
    hue = (color_hue-180)%360
    huediff = 30
    huearr = [hue]
  elif pal_type == 'Analg':
    huearr = [(color_hue-30)%360, (color_hue+30)%360]
    if subtype == "-":
      hue = (color_hue-30)%360
    else:
      hue = (color_hue+30)%360
    huediff = 15
  elif pal_type == 'Tri':
    huearr = [(color_hue-120)%360, (color_hue+120)%360]
    huediff = 15
    if subtype == "-":
      hue = (color_hue-240)%360
    else:
      hue = (color_hue+240)%360
  elif pal_type == 'Split':
    huearr = [(color_hue-150)%360, (color_hue+150)%360]
    huediff = 15
    if subtype == "-":
      hue = (color_hue-150)%360
    else:
      hue = (color_hue+150)%360 
  elif pal_type == 'Square':
    huearr = [(color_hue-180)%360, (color_hue-90)%360, (color_hue+90)%360]
    huediff = 5
    if subtype == "-":
      hue = (color_hue-90)%360
    else:
      hue = (color_hue+90)%360 
  elif pal_type == "Tetra1":
    huearr = [(color_hue-180)%360, (color_hue-30)%360, (color_hue+150)%360]
    huediff = 5
    if subtype == "2":
      hue = (color_hue-30)%360
    else:
      hue = (color_hue-150)%360
    subtype = "-"
  elif pal_type == "Tetra2":
    huearr = [(color_hue-180)%360, (color_hue+30)%360, (color_hue-150)%360]
    huediff = 5
    if subtype == "2":
      hue = (color_hue+30)%360
    else:
      hue = (color_hue+150)%360
    subtype = "+"
  if subtype == "comp":
    hue = (color_hue-180)%360
    huediff = 20
  df = color_df[abs(color_df['hue']-hue) < huediff] 
  count = len(df)
  distance,freq = hue_distance_calc(hue, xarr, yarr, df)

  row = [color, pal_type, subtype, count, count, distance, huearr] 
  row += list(freq)
  return row

def get_pallette(color_df, color, freqtable, color_quant = 0.1, pal_limit = 0.9, palette_length = 6):
  
  
  clock = ticktock(False)

  
  color_hue = float(freqtable[freqtable['name'] == color]['avg_hue'])
  og_sat = float(freqtable[freqtable['name'] == color]['avg_saturation'])
  og_light = float(freqtable[freqtable['name'] == color]['avg_lightness'])
  xarr,yarr = curvecheck(og_sat,og_light)
  #freqtable[abs(freqtable['avg_hue']-30) < 10].sort_values(by='freq', ascending = False)
  #clock.tock()

  insertarr = []
  insertarr.append(get_by_type("Self", "", color_df, color, freqtable, color_quant, pal_limit, palette_length, color_hue, xarr, yarr))
  insertarr.append(get_by_type("Comp", "", color_df, color, freqtable, color_quant, pal_limit, palette_length, color_hue, xarr, yarr))
  insertarr.append(get_by_type("Analg", "-", color_df, color, freqtable, color_quant, pal_limit, palette_length, color_hue, xarr, yarr))
  insertarr.append(get_by_type("Analg", "+", color_df, color, freqtable, color_quant, pal_limit, palette_length, color_hue, xarr, yarr))
  insertarr.append(get_by_type("Tri", "-", color_df, color, freqtable, color_quant, pal_limit, palette_length, color_hue, xarr, yarr))
  insertarr.append(get_by_type("Tri", "+", color_df, color, freqtable, color_quant, pal_limit, palette_length, color_hue, xarr, yarr))
  insertarr.append(get_by_type("Split", "-", color_df, color, freqtable, color_quant, pal_limit, palette_length, color_hue, xarr, yarr))
  insertarr.append(get_by_type("Split", "+", color_df, color, freqtable, color_quant, pal_limit, palette_length, color_hue, xarr, yarr))
  insertarr.append(get_by_type("Square", "-", color_df, color, freqtable, color_quant, pal_limit, palette_length, color_hue, xarr, yarr))
  insertarr.append(get_by_type("Square", "+", color_df, color, freqtable, color_quant, pal_limit, palette_length, color_hue, xarr, yarr))
  insertarr.append(get_by_type("Square", "comp", color_df, color, freqtable, color_quant, pal_limit, palette_length, color_hue, xarr, yarr))
  insertarr.append(get_by_type("Tetra1", "2", color_df, color, freqtable, color_quant, pal_limit, palette_length, color_hue, xarr, yarr))
  insertarr.append(get_by_type("Tetra1", "3", color_df, color, freqtable, color_quant, pal_limit, palette_length, color_hue, xarr, yarr))
  insertarr.append(get_by_type("Tetra1", "comp", color_df, color, freqtable, color_quant, pal_limit, palette_length, color_hue, xarr, yarr))
  insertarr.append(get_by_type("Tetra2", "2", color_df, color, freqtable, color_quant, pal_limit, palette_length, color_hue, xarr, yarr))
  insertarr.append(get_by_type("Tetra2", "3", color_df, color, freqtable, color_quant, pal_limit, palette_length, color_hue, xarr, yarr))
  insertarr.append(get_by_type("Tetra2", "comp", color_df, color, freqtable, color_quant, pal_limit, palette_length, color_hue, xarr, yarr))

  
  insertarr = np.asarray(insertarr)
  columns = ["prim_color", "type", "subtype", "count", "count%", "avg_distance", "hue_arr","f1", "f2", "f3", "f4","f5","f6","f7","f8", "f9", "f10"]
  
  distance_df = pd.DataFrame(columns = columns, data = insertarr)
  
  distance_df["count"] = pd.to_numeric(distance_df["count"])
  distance_df["count%"] = pd.to_numeric(distance_df["count%"])
  distance_df["count%"] /= distance_df["count"].sum()
  distance_df["avg_distance"] = pd.to_numeric(distance_df["avg_distance"])
  distance_df["count"] = pd.to_numeric(distance_df["count"])
  distance_df["f1"] = pd.to_numeric(distance_df["f1"])/distance_df["count"]
  distance_df["f2"] = pd.to_numeric(distance_df["f2"])/distance_df["count"]
  distance_df["f3"] = pd.to_numeric(distance_df["f3"])/distance_df["count"]
  distance_df["f4"] = pd.to_numeric(distance_df["f4"])/distance_df["count"]
  distance_df["f5"] = pd.to_numeric(distance_df["f5"])/distance_df["count"]
  distance_df["f6"] = pd.to_numeric(distance_df["f6"])/distance_df["count"]
  distance_df["f7"] = pd.to_numeric(distance_df["f7"])/distance_df["count"]
  distance_df["f8"] = pd.to_numeric(distance_df["f8"])/distance_df["count"]
  distance_df["f9"] = pd.to_numeric(distance_df["f9"])/distance_df["count"]
  distance_df["f10"] = pd.to_numeric(distance_df["f10"])/distance_df["count"]
  distance_df["avg_distance"] /= distance_df["count"]


  #clock.tock()


  k_exp = 1.4 #constant, balancing out the score
  score = distance_df["count"]*np.exp(distance_df["avg_distance"]*-1*k_exp)
  distance_df.insert(len(distance_df.columns), 'score',np.asarray(score))
  

  #clock.tock()



  return distance_df, color_hue, xarr, yarr

def construct_palette(pal_limit, ranking_df, distance_df, xarr, yarr, currtype, standard,color_df,palette_length=5, disp = False, clock = True):

  clock = ticktock(clock)
  #print(distance_df[distance_df['type'] == currtype]['hue_arr'].iloc[0])
  clock.tick()
  hue_arr = list(distance_df[distance_df['type'] == currtype]['hue_arr'].iloc[0])
  clock.tock("1")
  #print(hue_arr)
  #print(type(hue_arr))
  #print(currtype)
  #print("----------------------")
  typename = "UNCHANGED"
  curr_df = distance_df[distance_df["type"] == currtype]
  num_colors = len(curr_df)

  clock.tock("2")
  if currtype == "Analg":
    typename = "Analagous"
    minus_arr = curr_df[curr_df['subtype'] == "-"][["f1",'f2','f3','f4',"f5",'f6','f7','f8',"f9",'f10']]
    plus_arr = curr_df[curr_df['subtype'] == "+"][["f1",'f2','f3','f4',"f5",'f6','f7','f8',"f9",'f10']]
    ratio = float(curr_df[curr_df['subtype'] == "-"]['score'])/float(curr_df[curr_df['subtype'] == "+"]['score'])
    #print(curr_df[curr_df['subtype'] == "-"]['score'])
    #print(curr_df[curr_df['subtype'] == "+"]['score'])
    #print(ratio)
    if ratio > 2.5:
      #- is 30, + is 10
      #[analagous_hue1, analagous_hue2]
      swath1 = swath_gen(hue_arr[0], xarr,yarr, 3, minus_arr)
      swath2 = swath_gen(hue_arr[1], xarr,yarr, 1, plus_arr)
    elif ratio < .4:
      #- is 10, + is 30
      swath1 = swath_gen(hue_arr[0], xarr,yarr, 3, minus_arr)
      swath2 = swath_gen(hue_arr[1], xarr,yarr, 1, plus_arr)
    else:
      #- is 30, + is 30
      swath1 = swath_gen(hue_arr[0], xarr,yarr, 2, minus_arr)
      swath2 = swath_gen(hue_arr[1], xarr,yarr, 2, plus_arr)
  elif currtype == "Tetra1":
    typename = "Tetradic"
    comp_arr = curr_df[curr_df['subtype'] == "comp"][["f1",'f2','f3','f4',"f5",'f6','f7','f8',"f9",'f10']]
    minus_arr = curr_df[curr_df['subtype'] == "-"][["f1",'f2','f3','f4',"f5",'f6','f7','f8',"f9",'f10']]
    minus_comp_arr = curr_df[curr_df['subtype'] == "-comp"][["f1",'f2','f3','f4',"f5",'f6','f7','f8',"f9",'f10']]

    if float(curr_df['score'].max()) == float(curr_df[curr_df['subtype'] == "comp"]['score']):
      #[comphue, analagous_hue1, split_hue1]
      swath1 = swath_gen(hue_arr[0], xarr,yarr, 2, comp_arr)
      swath2 = swath_gen(hue_arr[1], xarr,yarr, 1, minus_arr)
      swath3 = swath_gen(hue_arr[2], xarr,yarr, 1, minus_comp_arr)
    elif float(curr_df['score'].max()) == float(curr_df[curr_df['subtype'] == "-"]['score']):
      swath1 = swath_gen(hue_arr[0], xarr,yarr, 1, comp_arr)
      swath2 = swath_gen(hue_arr[1], xarr,yarr, 2, minus_arr)
      swath3 = swath_gen(hue_arr[2], xarr,yarr, 1, minus_comp_arr)
    else:
      swath1 = swath_gen(hue_arr[0], xarr,yarr, 1, comp_arr)
      swath2 = swath_gen(hue_arr[1], xarr,yarr, 1, minus_arr)
      swath3 = swath_gen(hue_arr[2], xarr,yarr, 2, minus_comp_arr)
  elif currtype == "Tri":
    typename = "Triadic"
    minus_arr = curr_df[curr_df['subtype'] == "-"][["f1",'f2','f3','f4',"f5",'f6','f7','f8',"f9",'f10']]
    plus_arr = curr_df[curr_df['subtype'] == "+"][["f1",'f2','f3','f4',"f5",'f6','f7','f8',"f9",'f10']]
    ratio = float(curr_df[curr_df['subtype'] == "-"]['score'])/float(curr_df[curr_df['subtype'] == "+"]['score'])
    if ratio > 2.5:
      #- is 30, + is 10
      #[triadic_hue1, triadic_hue2]
      swath1 = swath_gen(hue_arr[0], xarr,yarr, 3, minus_arr)
      swath2 = swath_gen(hue_arr[1], xarr,yarr, 1, plus_arr)
    elif ratio < .4:
      #- is 10, + is 30
      swath1 = swath_gen(hue_arr[0], xarr,yarr, 1, minus_arr)
      swath2 = swath_gen(hue_arr[1], xarr,yarr, 3, plus_arr)
    else:
      #- is 30, + is 30
      swath1 = swath_gen(hue_arr[0], xarr,yarr, 2, minus_arr)
      swath2 = swath_gen(hue_arr[1], xarr,yarr, 2, plus_arr)
  elif currtype == "Square":

    typename = "Square"
    comp_arr = curr_df[curr_df['subtype'] == "comp"][["f1",'f2','f3','f4',"f5",'f6','f7','f8',"f9",'f10']]
    minus_arr = curr_df[curr_df['subtype'] == "-"][["f1",'f2','f3','f4',"f5",'f6','f7','f8',"f9",'f10']]
    plus_arr = curr_df[curr_df['subtype'] == "+"][["f1",'f2','f3','f4',"f5",'f6','f7','f8',"f9",'f10']]

    if float(curr_df['score'].max()) == float(curr_df[curr_df['subtype'] == "comp"]['score']):
      #[comphue, square_hue2, square_hue1]
      swath1 = swath_gen(hue_arr[0], xarr,yarr, 2, comp_arr)
      swath2 = swath_gen(hue_arr[1], xarr,yarr, 1, minus_arr)
      swath3 = swath_gen(hue_arr[2], xarr,yarr, 1, plus_arr)
    elif float(curr_df['score'].max()) == float(curr_df[curr_df['subtype'] == "-"]['score']):
      swath1 = swath_gen(hue_arr[0], xarr,yarr, 1, comp_arr)
      swath2 = swath_gen(hue_arr[1], xarr,yarr, 2, minus_arr)
      swath3 = swath_gen(hue_arr[2], xarr,yarr, 1, plus_arr)
    else:
      swath1 = swath_gen(hue_arr[0], xarr,yarr, 1, comp_arr)
      swath2 = swath_gen(hue_arr[1], xarr,yarr, 1, minus_arr)
      swath3 = swath_gen(hue_arr[2], xarr,yarr, 2, plus_arr)
  elif currtype == "Tetra2":
    typename = "Tetradic"
    comp_arr = curr_df[curr_df['subtype'] == "comp"][["f1",'f2','f3','f4',"f5",'f6','f7','f8',"f9",'f10']]
    plus_arr = curr_df[curr_df['subtype'] == "+"][["f1",'f2','f3','f4',"f5",'f6','f7','f8',"f9",'f10']]
    plus_comp_arr = curr_df[curr_df['subtype'] == "+comp"][["f1",'f2','f3','f4',"f5",'f6','f7','f8',"f9",'f10']]

    if curr_df['score'].max().convert_dtypes() == curr_df[curr_df['subtype'] == "comp"]['score'].convert_dtypes() :
      #[comphue, analagous_hue2, split_hue2]
      swath1 = swath_gen(hue_arr[0], xarr,yarr, 2, comp_arr)
      swath2 = swath_gen(hue_arr[1], xarr,yarr, 1, plus_arr)
      swath3 = swath_gen(hue_arr[2], xarr,yarr, 1, plus_comp_arr)
    elif float(curr_df['score'].max()) == float(curr_df[curr_df['subtype'] == "+"]['score']):
      swath1 = swath_gen(hue_arr[0], xarr,yarr, 1, comp_arr)
      swath2 = swath_gen(hue_arr[1], xarr,yarr, 2, plus_arr)
      swath3 = swath_gen(hue_arr[2], xarr,yarr, 1, plus_comp_arr)
    else:
      swath1 = swath_gen(hue_arr[0], xarr,yarr, 1, comp_arr)
      swath2 = swath_gen(hue_arr[1], xarr,yarr, 1, plus_arr)
      swath3 = swath_gen(hue_arr[2], xarr,yarr, 2, plus_comp_arr)
  elif currtype == "Split":
    typename = "Split"
    minus_arr = curr_df[curr_df['subtype'] == "-"][["f1",'f2','f3','f4',"f5",'f6','f7','f8',"f9",'f10']]
    plus_arr = curr_df[curr_df['subtype'] == "+"][["f1",'f2','f3','f4',"f5",'f6','f7','f8',"f9",'f10']]
    ratio = float(curr_df[curr_df['subtype'] == "-"]['score'])/float(curr_df[curr_df['subtype'] == "+"]['score'])
    if ratio > 2.5:
      #- is 30, + is 10
      #[split_hue2, split_hue1]
      swath1 = swath_gen(hue_arr[0], xarr,yarr, 3, minus_arr)
      swath2 = swath_gen(hue_arr[1], xarr,yarr, 1, plus_arr)
    elif ratio < .4:
      #- is 10, + is 30
      swath1 = swath_gen(hue_arr[0], xarr,yarr, 1, minus_arr)
      swath2 = swath_gen(hue_arr[1], xarr,yarr, 3, plus_arr)
    else:
      #- is 30, + is 30
      swath1 = swath_gen(hue_arr[0], xarr,yarr, 2, minus_arr)
      swath2 = swath_gen(hue_arr[1], xarr,yarr, 2, plus_arr)
  elif currtype == "Comp":
    typename = "Complimentary"
    #[comphue]
    rank_arr = curr_df[curr_df['type'] == "Comp"][["f1",'f2','f3','f4',"f5",'f6','f7','f8',"f9",'f10']]
    swath1 = swath_gen(hue_arr[0], xarr,yarr, 4, rank_arr)
  else:
    print(f"Invalid type: {currtype} (check for spelling errors)")

  clock.tock("3")

  hexarr = list(standard)[0]
  hexdict = {}
  for color_part in swath1:
    hexarr.append(tuple(convert_hsl_to_rgb(color_part)))
  clock.tock("3.1")

  if num_colors > 1:
    for color_part in swath2:
      hexarr.append(tuple(convert_hsl_to_rgb(color_part)))
  clock.tock("3.2")
  if num_colors > 2:
    for color_part in swath3:
      hexarr.append(tuple(convert_hsl_to_rgb(color_part)))
  clock.tock("3.3")
  
  
  clock.tock("4")
  #print(hexarr)
  #print(indices)
  #print(hexarr[indices])
  hexset = set(hexarr)
  clock.tock("5")
  hexarr = list(hexset)
  clock.tock("6")
  hexarr = np.asarray(hexarr)
  clock.tock("7")
  #print(hexarr)
  hexarr = np.asarray(n_mostcommon(color_df, hexarr, palette_length))
  clock.tock("8")

  if len(hexarr) < 5:
    return {"colors":[]}
  
  
  
  retDict = {'colors':[], 'strength': 0, 'base': "", 'type': typename}
  clock.tock("9")
  for triplet in hexarr:
    #print(triplet)
    if tuple(triplet) in colornamedict.keys():
      name = colornamedict[tuple(triplet)][0]
    else:
      name = convert_rgb_to_names(tuple(triplet))
      colornamedict[tuple(triplet)] = name
      name = name[0]
    hex = str(rgb_to_hex(triplet))
    hexclean = hex[1:]
    url = f"https://www.colorhexa.com/{hexclean}"
    retDict["colors"].append({"name": name, "hex": hex, "url":url})

  clock.tock("10")
  indices = np.linspace(0,len(hexarr)-1, len(hexarr)).reshape(1,len(hexarr)).astype(int)

  clock.tock("11")
  #print(hexarr)
  if disp:
    plt.imshow(hexarr[indices])

    plt.axis("off")

    plt.show()

    print("\n\n")

  return retDict

class ticktock:
  def __init__(self, display=True):
    self.totstart=  time.time()
    self.start = time.time()
    self.end = time.time()
    self.display = display
  def tick(self):
    self.start = time.time()
    selfend = time.time()
  def tock(self, message=  "", tocktick = True):
    self.end = time.time()
    timepassed = self.end-self.start
    if self.display:
      if not message == "":
        print(f"{message}: {timepassed} seconds passed")
      else:
        print(f"{timepassed} seconds passed")
    if tocktick:
      self.start = time.time()
    return timepassed

'''url = "https://www.pinterest.com/miraculouswip/posters/"
numsamples = 500
testcombo = assemble_df_direct(url, numsamples)
colornames, color_df = get_colordf(testcombo,0.4)
freqtable = get_freqtable(colornames,color_df, color_quant = 0.4)
freqtable.sort_values(by = 'freq', inplace = True, ascending = False)
name = colornames[0]
'''

def colornamedict_write():
  Details = ["r","g","b", "val", "dist"]  
  rows = [[k[0],k[1],k[2], v[0], v[1]] for k, v in colornamedict.items()]
  with open('colornamedict.csv', 'w') as f: 
      write = csv.writer(f) 
      write.writerow(Details) 
      write.writerows(rows)

def pinterest_palette(url = 'https://www.pinterest.com/miraculouswip/granola-stuff/', numsamples = 1000,  color_quant = 0.4, disp = False, write_cnd= False, clock = True):
  clock = ticktock(clock)
  runtime = ticktock(clock)
  runtime.tick()
  
  print("fetching image files...")
  clock.tick()
  '''
  
  result = getImageFiles(url)
  clock.tock()
  
  print("assembling pixel counts...")
  testcombo = assemble_df(result[0], result[1], numsamples)

  clock.tock()
  '''
  testcombo = assemble_df_direct(url, numsamples, disp)
  #print(testcombo)
  clock.tock("Assemble complete")
 
  print("filtering data...")
  colornames, color_df = get_colordf(testcombo,color_quant)

  clock.tock("filter complete")

  freqtable = get_freqtable(colornames,color_df, color_quant = color_quant)
  freqtable = freqtable[(freqtable["avg_lightness"] < 0.92) & (freqtable["avg_lightness"] > 0.08)]
  freqtable = freqtable[(freqtable["avg_saturation"] > 0.05)]
  freqtable.sort_values(by = 'freq', inplace = True, ascending = False)
  clock.tock("Freq table generated")
  #print("freqtable:")
  #print(freqtable.head(15))
  print("counting color frequency...")

  pal_limit=0.9
  distance_df_arr = []
  ranking_df_arr = []
  xy_arr = []
  clock.tock()
  for name in freqtable.head(10)["name"]:
    #clock.tock()
    #print(f"Computing color palettes for {name}")
    #print(f"|    {name}        |\n--------------------------")
    distance_df, color_hue, xarr, yarr = get_pallette(color_df, name, freqtable)
    #clock.tock("get palette complete")
    #print(f"Ranking {name}")
    ranking_df = get_rankingdf(distance_df, name)
    distance_df_arr.append(distance_df)
    ranking_df_arr.append(ranking_df)
    #clock.tock("Ranking complete")
    selflist = list(distance_df[distance_df["type"] == "Self"][["f1",'f2','f3','f4',"f5",'f6','f7','f8',"f9",'f10']].iloc[0])
    standard= swath_gen(color_hue, xarr, yarr, 2,selflist)
    for s in range(len(standard)):
      standard[s] = tuple(convert_hsl_to_rgb(standard[s]))
    
    xy_arr.append([name, xarr, yarr, standard])
    currtype = "Tri"
    #temporarily^
  clock.tock("Ranking complete")

  tot_distancedf = pd.concat(distance_df_arr, sort = False)
  tot_rankingdf = pd.concat(ranking_df_arr, sort = False)

  clock.tock("Assembling distance and ranking df complete")
  print("Computing best palettes")
  tot_distancedf = tot_distancedf.merge(freqtable[['name', 'freq']], how='inner', left_on = "prim_color", right_on = "name")
  #total_score = tot_distancedf["score"]*tot_distancedf["freq"]

  tot_distancedf['freq'] = pd.to_numeric(tot_distancedf['freq']).astype(float)

  

  logscore = np.log(tot_distancedf['freq'])

  tot_score = logscore*tot_distancedf['score']

  tot_distancedf.insert(len(tot_distancedf.columns), "tot_score",tot_score,True)

  xy_df = pd.DataFrame(columns = ["name", "xarr", "yarr", "standard"], data = xy_arr)


  tot_distancedf.sort_values(by='tot_score', inplace = True, ascending = False)
  #print(tot_distancedf)
  iterdf = tot_distancedf[tot_distancedf["type"] != 'Self']
  iterdf.reset_index(inplace = True)

  #print(iterdf.index)


  clock.tock()
  counter = 0
  i = 0
  retarr = []
  while counter < 10 and i < 20:
    
    tempname = str(iterdf.iloc[i]["name"])
    temptype = iterdf.iloc[i]["type"]
    temp_tot_score = iterdf.iloc[i]["tot_score"]
    score = temp_tot_score / tot_distancedf.iloc[0]["tot_score"]
    #print(f"rank {i+1}:{tempname}, {temptype}, score = {score * 100}%|\n--------------------------")
    #clock.tock()
    retDict = construct_palette(pal_limit, iterdf[iterdf["prim_color"] == tempname], iterdf[iterdf["prim_color"] == tempname], xy_df[xy_df["name"] == tempname]["xarr"], xy_df[xy_df["name"] == tempname]["yarr"], temptype, xy_df[xy_df["name"] == tempname]["standard"], color_df, clock = False)
    clock.tock()
    #print(iterdf.iloc[i]["name"])
    i+=1

    if len(retDict["colors"]) == 5:
      counter += 1
      retDict['base']= tempname
      retDict['strength'] = score
      retarr.append(retDict)
  clock.tock()
  if write_cnd:
    colornamedict_write()
  
  runtime.tock("\n\nTOTAL TIME RUN")
  return retarr

#add ur URL HERE!!!!

samplejson = pinterest_palette('https://www.pinterest.com/miraculouswip/soul-singers/', numsamples = 500, color_quant = 0.22, write_cnd = True)

jsonobj = json.dumps(samplejson, indent = 4)
with open("sample.json", "w") as f:
  f.write(jsonobj)
